#+TITLE: DOTS Info

* Table of Contents :TOC:
- [[#preface-why][Preface, "Why?"]]
- [[#required-packages][Required Packages]]
  - [[#dots-packages][DOTS Packages]]
- [[#platform-packages][Platform Packages]]
- [[#builds][Builds]]
- [[#entity-component-systems][Entity-Component-Systems]]
  - [[#comparison-of-models][Comparison of Models]]
  - [[#transformation-of-data][Transformation of Data]]
  - [[#concrete-example][Concrete example]]

* Preface, "Why?"
Unity is in the midst of a transformation that will fundamentally change the way
games are written. While those changes are not in the mainstream distribution of
the engine, it is imminent. This document aims to consolidate and summarise
information on the requirements and use of this new Data-Oriented Technology
Stack, and serve as a reference for project setup and development in the future.

It is still a good idea to learn the "classic", object-oriented approach taken
by both our game development module and the current series of learning materials
that Unity provides. Much of the programming, concepts and techniques will still
be useful and will still be necessary with some changes.
* Required Packages
** DOTS Packages
Installing the DOTS packages requires opening the Package Manger within the
project (Select =Window > Package Manager=), then add by name (select from the
drop-down "+" menu). Enter the following package names (one at a time):
+ =com.unity.entities=
+ =com.unity.rendering.hybrid=
+ =com.unity.dots.editor=
+ =com.unity.physics= \leftarrow The re-implementation of the physics engine built on DOTS
These packages are marked experimental, so be sure to save often and make use of
good version control practices. Be sure to push changes to the remote repository
often, and use branches when writing and testing new functionality before merging
with parent branches.

I expect we will be working simultaneously so we can work out any issues, talk
about problems etc. together.
*** Domain Reload
As noted in the [[https://docs.unity3d.com/Packages/com.unity.entities@0.17/manual/install_setup.html][entities documentation]], Domain Reload occurs when entering play
mode within the editor, and is especially slow when using DOTS. To disable this,
enable the "=Enter Play Mode Settings=" checkbox in the =Editor= section of the
Project Settings, while leaving its child options unchecked.
* Platform Packages
It is also necessary to install the DOTS based platform packages for Unity (The
default tool-chains will not be replaced by default).

Install, in the same way as above, the =com.unity.platforms.<platform>= packages,
where =<platform>= is the desired target, for example I will install
=com.unity.platforms.linux= and =com.unity.platforms.windows= to produce binaries
for Linux and Windows.
* Builds
Building through the standard =File > Build and Run= or =<ctrl+b>= will not work
with DOTS. You must create a "Classic Build Configuration" for each target
platform through the asset manager:

=+ > Build > <Platform> Classic Build Configuration=

From now on you must build the project by selecting this configuration and using
the options shown in the inspector.
* Entity-Component-Systems
** Comparison of Models
In the standard OOP model of game development, functionality is tied to
individual instances of objects. Each Monobehaviour (the class that from which
all standard scripts inherit) has its own ~Start()~, ~Update()~, similar and
accompanying methods. The engine will run all of these sequentially.

In this model, each game object is treated as a collection of data (the entity),
with this data organised into "components". These components are analogous to a
struct in C, they are mutable collections of data, they do not have their own
functionality (methods).
** Transformation of Data
It is the job of a =System= to read and transform the data of the entities. For
example you may have many entities with a ~Character~ component, each with an
~hp~ variable. This will include all players, enemies and NPCs. Characters may
be poisoned during the game, adding a ~Poison~ component to their entity. This
component will contain a value ~float rate~ to determine how much damage to deal
each second, and a ~float duration~ to determine how long the character will be
poisoned for.

You may define a ~StatusSystem~, which manages status effects (in this case
poisoning). It will operate on all of the entities with a ~Character~ /and/ a
~Poison~ component, and update the ~hp~ variable based on the data related to
the poison.

What will this look like?
** Concrete example
We write ~Character.cs~ as a struct inheriting ~IComponentData~.
#+begin_src csharp :exports code
using Unity.Entities;

// This tag allows us to set the fields in the editor like with a MonoBehaviour
[GenerateAuthoringComponent]
public struct Character : IComponentData {
    public float hp;
}
#+end_src

~Poison.cs~ will also inherit ~IComponentData~, but we don't need the authoring
component (since it would be added at runtime).
#+begin_src csharp :exports code
using Unity.Entities;

public struct Poison : IComponentData {
    public float rate;
    public float duration;
}
#+end_src

Finally the ~StatusSystem~, whose ~OnUpdate()~ method will perform the
transformation of data. This benefits from parallel execution through the C# Job
System.
#+begin_src csharp :exports code
using Unity.Entities;
using UnityEngine;

public partial class StatusSystem : SystemBase {
    EndSimulationEntityCommandBufferSystem m_EndSimulationECBSystem;

    protected override void OnCreate() {
        base.OnCreate();
        // This is how we make changes to the EntityManager within a job
        m_EndSimulationECBSystem = World
            .GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
    }
    protected override void OnUpdate() {
        // only local variables are captured in the lambda unless otherwise specified
        float dT = Time.DeltaTime;

        // create an entity command buffer suitable for parallel scheduled jobs
        var ecb = m_EndSimulationECBSystem
            .CreateCommandBuffer().AsParallelWriter();

        Entities
            .WithAll<Character, Poison>() // Only iterate over poisoned characters
            .ForEach(
                // define the lambda that transforms the data
                (ref Character ch, ref Poison poison, in Entity entity) => {
                ch.hp -= poison.rate * dT;
                poison.duration -= dT;
                if (poison.duration <= 1) // remove the poison component if it has expired
                    ecb.RemoveComponent<Poison>(entity); // using the Entity Command Buffer
                })
            .Burst() // free performance enhancement from the 'Burst Compiler'
            .ScheduleParallel();

        // Tell the system what we need
        m_EndSimulationECBSystem.AddJobHandlerForProducer(this.Dependency);
    }
}
#+end_src

Some keywords are used in the lambda definition that relate to C#'s implementation:
+ ~ref~ creates a mutable reference to the given argument
+ ~in~ creates an immutable reference to the argument (here we are not modifying
  ~entity~, only passing the reference to the ~EntityCommandBuffer~ in order to remove
  the component)
